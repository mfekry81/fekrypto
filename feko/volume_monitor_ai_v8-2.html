<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Volume Monitor v8-2 - WaveTrend Prediction</title>

  <!-- Bulma CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <style>
    body { background: #f9f9f9; }
    .navbar { margin-bottom: 2rem; }
    .title { font-size: 2rem; }
    .box { margin-bottom: 1rem; }
    table th, table td { text-align: center; vertical-align: middle; font-size: 11px; }
    .is-strong-buy { background-color: #a8e6a8; font-weight: bold; }
    .is-buy { background-color: #d4f8d4; }
    .is-sell { background-color: #ffd4d4; }
    .is-strong-sell { background-color: #ffb3b3; font-weight: bold; }
    .is-up { color: #23d160; }
    .is-down { color: #ff3860; }
    .pressure-indicator {
      padding: 3px 6px;
      border-radius: 3px;
      font-weight: bold;
      display: inline-block;
      font-size: 9px;
    }
    .pressure-buying { background-color: #48c774; color: white; }
    .pressure-selling { background-color: #f14668; color: white; }
    .pressure-neutral { background-color: #ffdd57; color: #333; }
    .confidence-meter {
      width: 100%;
      height: 5px;
      background: #e0e0e0;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 2px;
    }
    .confidence-fill {
      height: 100%;
      transition: width 0.3s ease;
    }
    .confidence-high { background: #48c774; }
    .confidence-medium { background: #ffdd57; }
    .confidence-low { background: #f14668; }
    .algorithm-badge {
      font-size: 9px;
      padding: 2px 5px;
      border-radius: 3px;
      background: #3273dc;
      color: white;
      margin-left: 5px;
    }
    .wavetrend-badge {
      font-size: 9px;
      padding: 2px 5px;
      border-radius: 3px;
      background: #9b59b6;
      color: white;
      margin-left: 3px;
    }
    .prediction-box {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 11px;
    }
    .target-up { 
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      color: white;
      padding: 3px 6px;
      border-radius: 3px;
      font-weight: bold;
      font-size: 10px;
    }
    .target-down { 
      background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      color: white;
      padding: 3px 6px;
      border-radius: 3px;
      font-weight: bold;
      font-size: 10px;
    }
    .crossover-badge {
      background: #00d1b2;
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: bold;
      animation: pulse 1s infinite;
    }
    .crossunder-badge {
      background: #f14668;
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: bold;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .wt-value {
      font-weight: bold;
      font-size: 10px;
    }
    .wt-overbought { color: #f14668; }
    .wt-oversold { color: #48c774; }
    .wt-neutral { color: #666; }
  </style>
</head>
<body>
  <section class="section">
    <div class="container">
      <p>
        <span style="font-size:26px;"><strong>Binance Market Watch v8-2</strong></span>
        <span class="algorithm-badge">WAVETREND AI</span>
        <span class="wavetrend-badge">CROSSOVER DETECTION</span><br>
        <span style="font-size:10px; color: #666;">5s Refresh | WaveTrend Oscillator + RSI + Volume Delta + Price Prediction on Cross Signals</span>
      </p>

      <!-- Selected Coin Data Section -->
      <div class="box">
        <label class="label">Select Coin</label>
        <div class="select">
          <select id="coinSelector">
            <option value="BTCUSDT">BTC/USDT</option>
            <option value="ETHUSDT">ETH/USDT</option>
            <option value="BNBUSDT">BNB/USDT</option>
            <option value="XRPUSDT">XRP/USDT</option>
            <option value="AVAXUSDT">AVAX/USDT</option>
            <option value="SOLUSDT">SOL/USDT</option>
            <option value="LINKUSDT">LINK/USDT</option>
            <option value="SUIUSDT">SUI/USDT</option>
            <option value="SEIUSDT">SEI/USDT</option>
            <option value="YGGUSDT">YGG/USDT</option>
            <option value="GALAUSDT">GALA/USDT</option>
            <option value="SKLUSDT">SKL/USDT</option>
            <option value="KAVAUSDT">KAVA/USDT</option>
            <option value="HBARUSDT">HBAR/USDT</option>
            <option value="APTUSDT">APT/USDT</option>
            <option value="INJUSDT">INJ/USDT</option>
            <option value="WLDUSDT">WLD/USDT</option>
            <option value="ARBUSDT">ARB/USDT</option>
            <option value="ONDOUSDT">ONDO/USDT</option>
            <option value="TIAUSDT">TIA/USDT</option>
            <option value="ORDIUSDT">ORDI/USDT</option>
          </select>
        </div>
        <button class="button is-info" id="loadData">Load Data</button>
        <button class="button is-warning" id="clearData">Clear History</button>
      </div>

      <div class="card">
        <div class="card-content">
          <h3 class="title is-6">WaveTrend Analysis + Price Prediction (5s Refresh)</h3>
          <table class="table is-bordered is-fullwidth" id="coinTable">
            <thead>
              <tr>
                <th>Coin</th>
                <th>Price</th>
                <th>1m %</th>
                <th>WT1</th>
                <th>WT2</th>
                <th>Cross Signal</th>
                <th>RSI</th>
                <th>Vol Î”</th>
                <th>Pressure</th>
                <th>AI Signal</th>
                <th>Target Price</th>
                <th>Time</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

    </div>
  </section>

  <!-- jQuery -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  <script>
    // Store previous WT values for crossover detection
    const previousWT = {};

    // Format price with proper decimals
    function formatPrice(price) {
      const num = parseFloat(price);
      if (num >= 1000) {
        return '$' + num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } else if (num >= 1) {
        return '$' + num.toLocaleString('en-US', { minimumFractionDigits: 3, maximumFractionDigits: 4 });
      } else if (num >= 0.01) {
        return '$' + num.toLocaleString('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 6 });
      } else {
        return '$' + num.toLocaleString('en-US', { minimumFractionDigits: 6, maximumFractionDigits: 8 });
      }
    }

    // Get local time
    function getLocalTime() {
      const now = new Date();
      return now.toLocaleString('en-US', { 
        month: '2-digit', 
        day: '2-digit', 
        hour: '2-digit', 
        minute: '2-digit', 
        second: '2-digit',
        hour12: false 
      });
    }

    // Calculate EMA
    function calculateEMA(data, period) {
      if (data.length < period) return data[data.length - 1] || 0;
      
      const multiplier = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      
      for (let i = period; i < data.length; i++) {
        ema = (data[i] - ema) * multiplier + ema;
      }
      
      return ema;
    }

    // Calculate WaveTrend Oscillator
    // Parameters: n1 = channel length (10), n2 = average length (21)
    function calculateWaveTrend(candles, n1 = 10, n2 = 21) {
      if (candles.length < n2 + 10) {
        return { wt1: 0, wt2: 0, wtCross: 'NONE' };
      }

      // Calculate HLC3 (typical price)
      const hlc3 = candles.map(c => {
        const high = parseFloat(c[2]);
        const low = parseFloat(c[3]);
        const close = parseFloat(c[4]);
        return (high + low + close) / 3;
      });

      // Calculate ESA (Exponential Moving Average of HLC3)
      const esa = calculateEMA(hlc3, n1);

      // Calculate absolute difference between HLC3 and ESA
      const diffs = hlc3.map(price => Math.abs(price - esa));
      
      // Calculate D (EMA of absolute differences)
      const d = calculateEMA(diffs, n1);

      // Calculate CI (Chande's Momentum Index)
      const ci = d !== 0 ? (hlc3[hlc3.length - 1] - esa) / (0.015 * d) : 0;

      // Create array of CI values (for EMA calculation)
      // Since we only have one CI value, we'll use it for both
      const tci = ci;

      // WT1 is the CI value
      const wt1 = tci;

      // WT2 is the EMA of WT1 (signal line)
      // For simplicity, we'll calculate an approximate WT2
      const wt2 = wt1 * 0.9; // Approximation for real-time

      return { wt1, wt2 };
    }

    // Calculate RSI
    function calculateRSI(candles, period = 14) {
      if (candles.length < period + 1) return 50;
      
      const changes = [];
      for (let i = 1; i < candles.length; i++) {
        const prevClose = parseFloat(candles[i - 1][4]);
        const currClose = parseFloat(candles[i][4]);
        changes.push(currClose - prevClose);
      }
      
      if (changes.length < period) return 50;
      
      const gains = changes.map(c => c > 0 ? c : 0);
      const losses = changes.map(c => c < 0 ? Math.abs(c) : 0);
      
      let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
      let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
      
      const alpha = 1 / period;
      for (let i = period; i < changes.length; i++) {
        avgGain = (gains[i] * alpha) + (avgGain * (1 - alpha));
        avgLoss = (losses[i] * alpha) + (avgLoss * (1 - alpha));
      }
      
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      const rsi = 100 - (100 / (1 + rs));
      
      return rsi;
    }

    // Calculate Volume Delta
    function calculateVolumeDelta(candles) {
      let buyVolume = 0;
      let sellVolume = 0;
      
      candles.forEach(candle => {
        const volume = parseFloat(candle[5]);
        const takerBuyVolume = parseFloat(candle[9]);
        
        buyVolume += takerBuyVolume;
        sellVolume += (volume - takerBuyVolume);
      });
      
      const totalVolume = buyVolume + sellVolume;
      const delta = totalVolume > 0 ? ((buyVolume - sellVolume) / totalVolume) * 100 : 0;
      
      return { delta, buyVolume, sellVolume };
    }

    // Calculate ATR
    function calculateATR(candles, period = 5) {
      if (candles.length < period) return 0;
      
      const ranges = [];
      for (let i = 1; i < candles.length; i++) {
        const high = parseFloat(candles[i][2]);
        const low = parseFloat(candles[i][3]);
        const prevClose = parseFloat(candles[i - 1][4]);
        
        const tr = Math.max(
          high - low,
          Math.abs(high - prevClose),
          Math.abs(low - prevClose)
        );
        ranges.push(tr);
      }
      
      const recentRanges = ranges.slice(-period);
      return recentRanges.reduce((a, b) => a + b, 0) / period;
    }

    // WAVETREND-BASED PRICE PREDICTION
    function predictPriceWithWaveTrend(currentPrice, wt1, wt2, wtCross, rsi, volumeDelta, atr) {
      let trendStrength = 0;
      let targetPrice = currentPrice;
      let probability = 50;

      // WaveTrend Cross Detection (50% weight)
      if (wtCross === 'CROSS_UP') {
        // Bullish crossover - WT1 crosses above WT2
        trendStrength += 50;
        probability += 20;
        
        // Stronger if in oversold territory (WT1 < -60)
        if (wt1 < -60) {
          trendStrength += 20;
          probability += 10;
        }
      } else if (wtCross === 'CROSS_DOWN') {
        // Bearish crossover - WT1 crosses below WT2
        trendStrength -= 50;
        probability += 20;
        
        // Stronger if in overbought territory (WT1 > 60)
        if (wt1 > 60) {
          trendStrength -= 20;
          probability += 10;
        }
      } else {
        // No cross - check divergence
        const divergence = wt1 - wt2;
        if (Math.abs(divergence) > 10) {
          trendStrength += divergence > 0 ? 20 : -20;
        }
      }

      // RSI confirmation (20% weight)
      if (rsi < 30) {
        trendStrength += 20;
        probability += 10;
      } else if (rsi > 70) {
        trendStrength -= 20;
        probability += 10;
      }

      // Volume Delta confirmation (15% weight)
      if (volumeDelta > 10) {
        trendStrength += 15;
        probability += 8;
      } else if (volumeDelta < -10) {
        trendStrength -= 15;
        probability += 8;
      }

      // WaveTrend position (15% weight)
      if (wt1 < -60) {
        trendStrength += 15; // Oversold - bullish
      } else if (wt1 > 60) {
        trendStrength -= 15; // Overbought - bearish
      }

      // Calculate target based on ATR and trend strength
      const volatilityMultiplier = atr / currentPrice;
      const moveMultiplier = Math.abs(trendStrength) / 50;
      
      if (trendStrength > 0) {
        // Bullish
        const targetMove = atr * moveMultiplier * 2;
        targetPrice = currentPrice + targetMove;
      } else if (trendStrength < 0) {
        // Bearish
        const targetMove = atr * moveMultiplier * 2;
        targetPrice = currentPrice - targetMove;
      }

      probability = Math.min(95, Math.max(55, probability));

      return {
        targetPrice: targetPrice,
        direction: trendStrength > 0 ? 'UP' : trendStrength < 0 ? 'DOWN' : 'NEUTRAL',
        probability: probability,
        trendStrength: trendStrength
      };
    }

    // Get 1-minute change
    async function get1MinChange(coin) {
      return new Promise((resolve) => {
        const url = `https://api.binance.com/api/v3/klines?symbol=${coin}&interval=1m&limit=2`;
        $.getJSON(url, function(data) {
          if (data && data.length >= 2) {
            const prevClose = parseFloat(data[0][4]);
            const currentClose = parseFloat(data[1][4]);
            const change = ((currentClose - prevClose) / prevClose) * 100;
            resolve(change);
          } else {
            resolve(0);
          }
        }).fail(function() {
          resolve(0);
        });
      });
    }

    // Fetch candle data
    async function fetchCandleData(coin, interval = '3m', limit = 50) {
      return new Promise((resolve) => {
        const url = `https://api.binance.com/api/v3/klines?symbol=${coin}&interval=${interval}&limit=${limit}`;
        $.getJSON(url, function(data) {
          resolve(data);
        }).fail(function() {
          resolve([]);
        });
      });
    }

    // Main fetch function
    async function fetchSelectedCoinData(coin) {
      try {
        const candles = await fetchCandleData(coin, '3m', 50);
        
        if (candles.length === 0) {
          console.error("No candle data available");
          return;
        }
        
        const oneMinChange = await get1MinChange(coin);
        const currentPrice = parseFloat(candles[candles.length - 1][4]);
        
        // Calculate WaveTrend
        const wt = calculateWaveTrend(candles, 10, 21);
        
        // Detect crossover/crossunder
        let wtCross = 'NONE';
        const prevWT = previousWT[coin];
        
        if (prevWT) {
          // Cross Up: WT1 crosses above WT2
          if (prevWT.wt1 <= prevWT.wt2 && wt.wt1 > wt.wt2) {
            wtCross = 'CROSS_UP';
          }
          // Cross Down: WT1 crosses below WT2
          else if (prevWT.wt1 >= prevWT.wt2 && wt.wt1 < wt.wt2) {
            wtCross = 'CROSS_DOWN';
          }
        }
        
        // Store current WT for next iteration
        previousWT[coin] = { wt1: wt.wt1, wt2: wt.wt2 };
        
        // Calculate other indicators
        const rsi = calculateRSI(candles, 14);
        const volumeDeltaData = calculateVolumeDelta(candles.slice(-5));
        const atr = calculateATR(candles, 5);
        
        // Get price prediction
        const prediction = predictPriceWithWaveTrend(
          currentPrice,
          wt.wt1,
          wt.wt2,
          wtCross,
          rsi,
          volumeDeltaData.delta,
          atr
        );
        
        // Determine signal based on WaveTrend
        let signal, css, direction;
        if (wtCross === 'CROSS_UP') {
          signal = "STRONG BUY ðŸš€";
          css = "is-strong-buy";
          direction = "BULLISH CROSS";
        } else if (wtCross === 'CROSS_DOWN') {
          signal = "STRONG SELL âš ";
          css = "is-strong-sell";
          direction = "BEARISH CROSS";
        } else if (wt.wt1 > wt.wt2 && wt.wt1 > 0) {
          signal = "BUY â¬†";
          css = "is-buy";
          direction = "BULLISH";
        } else if (wt.wt1 < wt.wt2 && wt.wt1 < 0) {
          signal = "SELL â¬‡";
          css = "is-sell";
          direction = "BEARISH";
        } else {
          signal = "HOLD â¸±";
          css = "";
          direction = "NEUTRAL";
        }
        
        // Determine colors
        const oneMinClass = oneMinChange >= 0 ? 'is-up' : 'is-down';
        const rsiColor = rsi < 40 ? 'is-up' : rsi > 60 ? 'is-down' : '';
        const volumeDeltaColor = volumeDeltaData.delta > 2 ? 'is-up' : volumeDeltaData.delta < -2 ? 'is-down' : '';
        
        const wt1Class = wt.wt1 < -60 ? 'wt-oversold' : wt.wt1 > 60 ? 'wt-overbought' : 'wt-neutral';
        const wt2Class = wt.wt2 < -60 ? 'wt-oversold' : wt.wt2 > 60 ? 'wt-overbought' : 'wt-neutral';
        
        const localTime = getLocalTime();
        
        const targetClass = prediction.direction === 'UP' ? 'target-up' : prediction.direction === 'DOWN' ? 'target-down' : 'target-up';
        const targetArrow = prediction.direction === 'UP' ? 'â†‘' : prediction.direction === 'DOWN' ? 'â†“' : 'â†’';
        
        let crossBadge = '';
        if (wtCross === 'CROSS_UP') {
          crossBadge = '<span class="crossover-badge">CROSS UP â¬†</span>';
        } else if (wtCross === 'CROSS_DOWN') {
          crossBadge = '<span class="crossunder-badge">CROSS DOWN â¬‡</span>';
        } else {
          crossBadge = '<span style="font-size:9px; color:#999;">No Cross</span>';
        }
        
        const row = `
          <tr class="${css}">
            <td><strong>${coin}</strong></td>
            <td>${formatPrice(currentPrice)}</td>
            <td class="${oneMinClass}"><strong>${oneMinChange >= 0 ? '+' : ''}${oneMinChange.toFixed(3)}%</strong></td>
            <td class="${wt1Class} wt-value">${wt.wt1.toFixed(1)}</td>
            <td class="${wt2Class} wt-value">${wt.wt2.toFixed(1)}</td>
            <td>${crossBadge}</td>
            <td class="${rsiColor}"><strong>${rsi.toFixed(0)}</strong></td>
            <td class="${volumeDeltaColor}"><strong>${volumeDeltaData.delta.toFixed(1)}%</strong></td>
            <td>
              <span class="pressure-indicator ${direction.includes('BULLISH') ? 'pressure-buying' : direction.includes('BEARISH') ? 'pressure-selling' : 'pressure-neutral'}">
                ${direction}
              </span>
            </td>
            <td><strong>${signal}</strong></td>
            <td>
              <span class="${targetClass}">
                ${targetArrow} ${formatPrice(prediction.targetPrice)}
              </span><br>
              <small style="font-size:8px;">${prediction.probability.toFixed(0)}% prob</small>
            </td>
            <td style="font-size: 9px;">${localTime}</td>
          </tr>
        `;

        $("#coinTable tbody").prepend(row);
        if ($("#coinTable tbody tr").length > 20) {
          $("#coinTable tbody tr:last").remove();
        }
        
      } catch (error) {
        console.error("Error in analysis:", error);
      }
    }

    $(document).ready(function() {
      $('#loadData').click(function(){
        const coin = $('#coinSelector').val();
        fetchSelectedCoinData(coin);
      });

      $('#clearData').click(function(){
        $("#coinTable tbody").empty();
      });

      // Auto-refresh every 5 seconds
      setInterval(function(){
        const coin = $('#coinSelector').val();
        if ($("#coinTable tbody tr").length > 0) {
          fetchSelectedCoinData(coin);
        }
      }, 5000);
    });
  </script>
</body>
</html>