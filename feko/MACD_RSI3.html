<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Crypto Expert - Binance Market Watch</title>
    <style>
        :root {
            --primary: #f0b90b;
            --primary-dark: #b8940f;
            --bg-dark: #0a0e17;
            --bg-card: #141b29;
            --bg-card-hover: #1a2335;
            --text-primary: #eaecef;
            --text-secondary: #848e9c;
            --success: #00b15d;
            --danger: #f6465d;
            --warning: #f0b90b;
            --info: #2980ff;
            --border: #2a2e39;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.8rem;
            color: var(--primary);
        }

        .live-clock {
            font-size: 1.2rem;
            background: var(--bg-card);
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid var(--primary);
        }

        .stats-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-card);
            border-radius: 8px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--danger);
        }

        .status-indicator.connected {
            background: var(--success);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            background: var(--bg-card);
            padding: 15px;
            border-radius: 8px;
        }

        .control-group h3 {
            margin-bottom: 10px;
            color: var(--primary);
            font-size: 1rem;
        }

        select, input, button {
            width: 100%;
            padding: 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        button {
            background: var(--primary);
            color: var(--bg-dark);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: var(--primary-dark);
        }

        button.secondary {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .symbol-selector {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 10px;
        }

        .symbol-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .symbol-checkbox input {
            width: auto;
            margin-right: 8px;
        }

        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .signal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .signal-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s;
            border-left: 4px solid var(--text-secondary);
        }

        .signal-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            background: var(--bg-card-hover);
        }

        .signal-card.bullish {
            border-left-color: var(--success);
            animation: pulse-green 2s infinite;
        }

        .signal-card.bearish {
            border-left-color: var(--danger);
            animation: pulse-red 2s infinite;
        }

        .signal-card.potential {
            border-left-color: var(--warning);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .symbol {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .signal-badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .signal-badge.buy {
            background: var(--success);
            color: white;
        }

        .signal-badge.sell {
            background: var(--danger);
            color: white;
        }

        .signal-badge.strong-buy {
            background: var(--success);
            color: white;
            animation: glow-green 1.5s infinite alternate;
        }

        .signal-badge.strong-sell {
            background: var(--danger);
            color: white;
            animation: glow-red 1.5s infinite alternate;
        }

        .signal-badge.partial {
            background: var(--warning);
            color: var(--bg-dark);
        }

        .signal-badge.conflict {
            background: var(--info);
            color: white;
        }

        .card-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.85rem;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
        }

        .detail-label {
            color: var(--text-secondary);
        }

        .detail-value {
            font-weight: bold;
        }

        .timestamp {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 10px;
            text-align: right;
        }

        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .pagination button {
            width: auto;
            padding: 5px 15px;
        }

        .pagination button.active {
            background: var(--primary-dark);
        }

        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(0, 177, 93, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 177, 93, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 177, 93, 0); }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(246, 70, 93, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(246, 70, 93, 0); }
            100% { box-shadow: 0 0 0 0 rgba(246, 70, 93, 0); }
        }

        @keyframes glow-green {
            from { box-shadow: 0 0 5px var(--success); }
            to { box-shadow: 0 0 15px var(--success); }
        }

        @keyframes glow-red {
            from { box-shadow: 0 0 5px var(--danger); }
            to { box-shadow: 0 0 15px var(--danger); }
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .signal-grid {
                grid-template-columns: 1fr;
            }
            
            header {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <h1>AI Crypto Expert - Binance Market Watch</h1>
            </div>
            <div class="live-clock" id="liveClock">Loading...</div>
        </header>

        <div class="stats-bar">
            <div class="stat-item">
                <div class="status-indicator" id="connectionStatus"></div>
                <span id="connectionText">Disconnected</span>
            </div>
            <div class="stat-item">
                <span>Bullish Signals:</span>
                <span id="bullishCount">0</span>
            </div>
            <div class="stat-item">
                <span>Bearish Signals:</span>
                <span id="bearishCount">0</span>
            </div>
            <div class="stat-item">
                <span>Potential Signals:</span>
                <span id="potentialCount">0</span>
            </div>
            <div class="stat-item">
                <span>Active Symbols:</span>
                <span id="activeSymbols">0</span>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>Symbol Selection</h3>
                <button id="refreshSymbols">Refresh Symbol List</button>
                <div class="symbol-selector" id="symbolSelector">
                    <!-- Symbols will be populated here -->
                </div>
                <button id="selectAll">Select All</button>
                <button id="deselectAll">Deselect All</button>
            </div>

            <div class="control-group">
                <h3>Timeframe & Parameters</h3>
                <select id="timeframe">
                    <option value="5m">5 Minutes</option>
                    <option value="15m">15 Minutes</option>
                    <option value="1h">1 Hour</option>
                    <option value="4h">4 Hours</option>
                    <option value="1d">1 Day</option>
                </select>
                
                <h4>MACD Parameters</h4>
                <input type="number" id="macdFast" placeholder="Fast Length (12)" value="12">
                <input type="number" id="macdSlow" placeholder="Slow Length (26)" value="26">
                <input type="number" id="macdSignal" placeholder="Signal Length (9)" value="9">
                
                <h4>Stoch RSI Parameters</h4>
                <input type="number" id="stochRsiLength" placeholder="RSI Length (14)" value="14">
                <input type="number" id="stochLength" placeholder="Stoch Length (14)" value="14">
            </div>

            <div class="control-group">
                <h3>Thresholds</h3>
                <h4>MACD Thresholds</h4>
                <input type="number" step="0.0001" id="strongMacdBuy" placeholder="Strong Buy Threshold (-0.0001)" value="-0.0001">
                <input type="number" step="0.0001" id="strongMacdSell" placeholder="Strong Sell Threshold (0.0001)" value="0.0001">
                
                <h4>Stoch RSI Thresholds</h4>
                <input type="number" id="stochOversold" placeholder="Oversold (20)" value="20">
                <input type="number" id="stochOverbought" placeholder="Overbought (80)" value="80">
                
                <h4>Volume Filter</h4>
                <input type="number" id="minVolume" placeholder="Minimum Volume (0 = disabled)" value="0">
            </div>

            <div class="control-group">
                <h3>Controls</h3>
                <button id="startStop">Start Monitoring</button>
                <button id="clearCache" class="secondary">Clear Cache</button>
                <button id="testMode" class="secondary">Test Mode</button>
                
                <div class="filter-group">
                    <label for="signalFilter">Signal Filter:</label>
                    <select id="signalFilter">
                        <option value="all">All Signals</option>
                        <option value="bullish" selected>Bullish Only</option>
                        <option value="bearish">Bearish Only</option>
                        <option value="potential">Potential Only</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="searchSymbol">Search Symbol:</label>
                    <input type="text" id="searchSymbol" placeholder="e.g., BTCUSDT">
                </div>
            </div>
        </div>

        <div class="filters">
            <div class="filter-group">
                <label for="sortBy">Sort By:</label>
                <select id="sortBy">
                    <option value="signal-strength">Signal Strength</option>
                    <option value="symbol">Symbol</option>
                    <option value="volume">Volume</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label for="resultsLimit">Results Limit:</label>
                <select id="resultsLimit">
                    <option value="10">Top 10</option>
                    <option value="25">Top 25</option>
                    <option value="50" selected>Top 50</option>
                    <option value="100">Top 100</option>
                    <option value="0">All</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label for="autoRefresh">Auto Refresh:</label>
                <select id="autoRefresh">
                    <option value="300000" selected>Every 5 Minutes</option>
                    <option value="60000">Every Minute</option>
                    <option value="0">Manual Only</option>
                </select>
            </div>
            
            <button id="manualRefresh">Refresh Now</button>
        </div>

        <div class="signal-grid" id="signalGrid">
            <!-- Signal cards will be populated here -->
        </div>

        <div class="pagination" id="pagination">
            <!-- Pagination will be populated here -->
        </div>
    </div>

    <script>
        // Global variables
        let symbols = [];
        let selectedSymbols = [];
        let websocket = null;
        let isMonitoring = false;
        let symbolData = {};
        let currentPage = 1;
        const itemsPerPage = 20;
        let refreshInterval = null;
        let lastRefreshTime = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeClock();
            loadSymbols();
            setupEventListeners();
        });

        // Update live clock
        function initializeClock() {
            function updateClock() {
                const now = new Date();
                document.getElementById('liveClock').textContent = now.toLocaleString();
            }
            updateClock();
            setInterval(updateClock, 1000);
        }

        // Load available symbols from Binance
        async function loadSymbols() {
            try {
                const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await response.json();
                
                symbols = data.symbols
                    .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
                    .map(s => s.symbol);
                
                populateSymbolSelector();
            } catch (error) {
                console.error('Error loading symbols:', error);
                // Fallback to a predefined list if API fails
                symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'DOGEUSDT', 
                          'XRPUSDT', 'DOTUSDT', 'UNIUSDT', 'LTCUSDT', 'LINKUSDT',
                          'BCHUSDT', 'XLMUSDT', 'FILUSDT', 'TRXUSDT', 'ETCUSDT',
                          'THETAUSDT', 'VETUSDT', 'MATICUSDT', 'EOSUSDT', 'AAVEUSDT'];
                populateSymbolSelector();
            }
        }

        // Populate the symbol selector with checkboxes
        function populateSymbolSelector() {
            const container = document.getElementById('symbolSelector');
            container.innerHTML = '';
            
            symbols.forEach(symbol => {
                const div = document.createElement('div');
                div.className = 'symbol-checkbox';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `symbol-${symbol}`;
                checkbox.value = symbol;
                checkbox.checked = selectedSymbols.includes(symbol);
                
                const label = document.createElement('label');
                label.htmlFor = `symbol-${symbol}`;
                label.textContent = symbol;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
                
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        if (!selectedSymbols.includes(this.value)) {
                            selectedSymbols.push(this.value);
                        }
                    } else {
                        const index = selectedSymbols.indexOf(this.value);
                        if (index > -1) {
                            selectedSymbols.splice(index, 1);
                        }
                    }
                    updateActiveSymbolsCount();
                });
            });
            
            updateActiveSymbolsCount();
        }

        // Update the active symbols count in the stats bar
        function updateActiveSymbolsCount() {
            document.getElementById('activeSymbols').textContent = selectedSymbols.length;
        }

        // Set up event listeners for buttons and controls
        function setupEventListeners() {
            document.getElementById('refreshSymbols').addEventListener('click', loadSymbols);
            document.getElementById('selectAll').addEventListener('click', selectAllSymbols);
            document.getElementById('deselectAll').addEventListener('click', deselectAllSymbols);
            document.getElementById('startStop').addEventListener('click', toggleMonitoring);
            document.getElementById('clearCache').addEventListener('click', clearCache);
            document.getElementById('testMode').addEventListener('click', runTestMode);
            document.getElementById('manualRefresh').addEventListener('click', manualRefresh);
            
            document.getElementById('signalFilter').addEventListener('change', filterSignals);
            document.getElementById('searchSymbol').addEventListener('input', filterSignals);
            document.getElementById('sortBy').addEventListener('change', filterSignals);
            document.getElementById('resultsLimit').addEventListener('change', filterSignals);
            document.getElementById('autoRefresh').addEventListener('change', setupAutoRefresh);
            
            // Set up auto-refresh
            setupAutoRefresh();
        }

        // Select all symbols
        function selectAllSymbols() {
            selectedSymbols = [...symbols];
            document.querySelectorAll('#symbolSelector input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = true;
            });
            updateActiveSymbolsCount();
        }

        // Deselect all symbols
        function deselectAllSymbols() {
            selectedSymbols = [];
            document.querySelectorAll('#symbolSelector input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateActiveSymbolsCount();
        }

        // Toggle monitoring on/off
        function toggleMonitoring() {
            if (isMonitoring) {
                stopMonitoring();
                document.getElementById('startStop').textContent = 'Start Monitoring';
            } else {
                startMonitoring();
                document.getElementById('startStop').textContent = 'Stop Monitoring';
            }
            isMonitoring = !isMonitoring;
        }

        // Start monitoring selected symbols
        function startMonitoring() {
            if (selectedSymbols.length === 0) {
                alert('Please select at least one symbol to monitor.');
                return;
            }
            
            // Initialize data structure for each symbol
            selectedSymbols.forEach(symbol => {
                if (!symbolData[symbol]) {
                    symbolData[symbol] = {
                        candles: [],
                        emaFast: null,
                        emaSlow: null,
                        macdLine: null,
                        signalLine: null,
                        rsi: null,
                        stochK: null,
                        stochD: null,
                        lastSignal: null,
                        volume: 0
                    };
                }
            });
            
            // Connect to WebSocket
            connectWebSocket();
            
            // Update UI
            document.getElementById('connectionStatus').className = 'status-indicator connected';
            document.getElementById('connectionText').textContent = 'Connected';
        }

        // Stop monitoring
        function stopMonitoring() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            
            // Update UI
            document.getElementById('connectionStatus').className = 'status-indicator';
            document.getElementById('connectionText').textContent = 'Disconnected';
        }

        // Connect to Binance WebSocket
        function connectWebSocket() {
            const timeframe = document.getElementById('timeframe').value;
            const streams = selectedSymbols.map(symbol => `${symbol.toLowerCase()}@kline_${timeframe}`).join('/');
            const wsUrl = `wss://stream.binance.com:9443/stream?streams=${streams}`;
            
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = function() {
                console.log('WebSocket connected');
                document.getElementById('connectionStatus').className = 'status-indicator connected';
                document.getElementById('connectionText').textContent = 'Connected';
            };
            
            websocket.onmessage = function(event) {
                const message = JSON.parse(event.data);
                if (message.data && message.data.e === 'kline') {
                    processKlineData(message.data);
                }
            };
            
            websocket.onclose = function() {
                console.log('WebSocket disconnected');
                document.getElementById('connectionStatus').className = 'status-indicator';
                document.getElementById('connectionText').textContent = 'Disconnected';
                
                // Attempt to reconnect after a delay
                setTimeout(connectWebSocket, 5000);
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        // Process incoming kline data
        function processKlineData(klineData) {
            const symbol = klineData.s;
            const candle = {
                open: parseFloat(klineData.k.o),
                high: parseFloat(klineData.k.h),
                low: parseFloat(klineData.k.l),
                close: parseFloat(klineData.k.c),
                volume: parseFloat(klineData.k.v),
                timestamp: klineData.k.t,
                isFinal: klineData.k.x
            };
            
            // Only process final candles
            if (!candle.isFinal) return;
            
            // Add candle to symbol's data
            if (!symbolData[symbol]) return;
            
            symbolData[symbol].candles.push(candle);
            symbolData[symbol].volume = candle.volume;
            
            // Keep only the last 100 candles to manage memory
            if (symbolData[symbol].candles.length > 100) {
                symbolData[symbol].candles.shift();
            }
            
            // Calculate indicators
            calculateIndicators(symbol);
            
            // Check for signals
            checkSignals(symbol);
            
            // Update UI
            updateSignalDisplay();
        }

        // Calculate technical indicators for a symbol
        function calculateIndicators(symbol) {
            const data = symbolData[symbol];
            const candles = data.candles;
            
            if (candles.length < 26) return; // Need enough data
            
            // Get parameters from UI
            const fastLength = parseInt(document.getElementById('macdFast').value) || 12;
            const slowLength = parseInt(document.getElementById('macdSlow').value) || 26;
            const signalLength = parseInt(document.getElementById('macdSignal').value) || 9;
            const rsiLength = parseInt(document.getElementById('stochRsiLength').value) || 14;
            const stochLength = parseInt(document.getElementById('stochLength').value) || 14;
            
            // Calculate EMA fast
            data.emaFast = calculateEMA(candles.map(c => c.close), fastLength);
            
            // Calculate EMA slow
            data.emaSlow = calculateEMA(candles.map(c => c.close), slowLength);
            
            // Calculate MACD line
            if (data.emaFast !== null && data.emaSlow !== null) {
                data.macdLine = data.emaFast - data.emaSlow;
            }
            
            // Calculate Signal line (EMA of MACD)
            if (data.macdLine !== null) {
                // We need multiple MACD values for the signal line
                // For simplicity, we'll use the current MACD value only
                // In a real implementation, we'd track historical MACD values
                data.signalLine = data.macdLine; // Simplified
            }
            
            // Calculate RSI
            data.rsi = calculateRSI(candles.map(c => c.close), rsiLength);
            
            // Calculate Stochastic RSI
            if (data.rsi !== null) {
                // For simplicity, we'll calculate a basic Stoch RSI
                // In a real implementation, we'd track RSI values over the stochLength period
                data.stochK = data.rsi; // Simplified
                data.stochD = data.rsi; // Simplified
            }
        }

        // Calculate EMA (Exponential Moving Average)
        function calculateEMA(data, period) {
            if (data.length < period) return null;
            
            const multiplier = 2 / (period + 1);
            let ema = data[0];
            
            for (let i = 1; i < data.length; i++) {
                ema = (data[i] - ema) * multiplier + ema;
            }
            
            return ema;
        }

        // Calculate RSI (Relative Strength Index)
        function calculateRSI(data, period) {
            if (data.length < period + 1) return null;
            
            let gains = 0;
            let losses = 0;
            
            // Calculate initial average gains and losses
            for (let i = 1; i <= period; i++) {
                const change = data[i] - data[i-1];
                if (change >= 0) {
                    gains += change;
                } else {
                    losses -= change;
                }
            }
            
            let avgGain = gains / period;
            let avgLoss = losses / period;
            
            // Calculate subsequent values using Wilder's smoothing
            for (let i = period + 1; i < data.length; i++) {
                const change = data[i] - data[i-1];
                
                if (change >= 0) {
                    avgGain = (avgGain * (period - 1) + change) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) - change) / period;
                }
            }
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        // Check for trading signals
        function checkSignals(symbol) {
            const data = symbolData[symbol];
            if (!data.macdLine || !data.signalLine || !data.stochK || !data.stochD) return;
            
            // Get thresholds from UI
            const strongMacdBuy = parseFloat(document.getElementById('strongMacdBuy').value) || -0.0001;
            const strongMacdSell = parseFloat(document.getElementById('strongMacdSell').value) || 0.0001;
            const stochOversold = parseFloat(document.getElementById('stochOversold').value) || 20;
            const stochOverbought = parseFloat(document.getElementById('stochOverbought').value) || 80;
            
            // Check for MACD cross
            let macdSignal = 'NEUTRAL';
            let macdCrossType = '';
            
            // Simplified cross detection (in real implementation, we'd compare current and previous values)
            if (data.macdLine > data.signalLine) {
                macdCrossType = 'UP';
                if (data.macdLine < strongMacdBuy) {
                    macdSignal = 'STRONG BUY';
                } else {
                    macdSignal = 'BUY';
                }
            } else if (data.macdLine < data.signalLine) {
                macdCrossType = 'DOWN';
                if (data.macdLine > strongMacdSell) {
                    macdSignal = 'STRONG SELL';
                } else {
                    macdSignal = 'SELL';
                }
            }
            
            // Check for Stoch RSI cross
            let stochSignal = 'NEUTRAL';
            let stochCrossType = '';
            
            // Simplified cross detection
            if (data.stochK > data.stochD) {
                stochCrossType = 'UP';
                if (data.stochK < stochOversold) {
                    stochSignal = 'STRONG BUY';
                } else {
                    stochSignal = 'BUY';
                }
            } else if (data.stochK < data.stochD) {
                stochCrossType = 'DOWN';
                if (data.stochK > stochOverbought) {
                    stochSignal = 'STRONG SELL';
                } else {
                    stochSignal = 'SELL';
                }
            }
            
            // Determine combined signal
            let combinedSignal = 'NO SIGNAL';
            let reason = '';
            
            if (macdSignal.includes('BUY') && stochSignal.includes('BUY')) {
                if (macdSignal === 'STRONG BUY' && stochSignal === 'STRONG BUY') {
                    combinedSignal = 'STRONG BUY';
                } else {
                    combinedSignal = 'BUY';
                }
                reason = `MACD ${macdCrossType} cross at ${data.macdLine.toFixed(6)}, Stoch RSI ${stochCrossType} cross at ${data.stochK.toFixed(2)}`;
            } else if (macdSignal.includes('SELL') && stochSignal.includes('SELL')) {
                if (macdSignal === 'STRONG SELL' && stochSignal === 'STRONG SELL') {
                    combinedSignal = 'STRONG SELL';
                } else {
                    combinedSignal = 'SELL';
                }
                reason = `MACD ${macdCrossType} cross at ${data.macdLine.toFixed(6)}, Stoch RSI ${stochCrossType} cross at ${data.stochK.toFixed(2)}`;
            } else if (macdSignal !== 'NEUTRAL' && stochSignal !== 'NEUTRAL') {
                combinedSignal = 'CONFLICT';
                reason = `MACD: ${macdSignal}, Stoch RSI: ${stochSignal}`;
            } else if (macdSignal !== 'NEUTRAL' || stochSignal !== 'NEUTRAL') {
                combinedSignal = 'PARTIAL';
                reason = macdSignal !== 'NEUTRAL' ? `MACD: ${macdSignal}` : `Stoch RSI: ${stochSignal}`;
            }
            
            // Check for potential cross (within 0.2% of each other)
            const macdDiff = Math.abs(data.macdLine - data.signalLine);
            const stochDiff = Math.abs(data.stochK - data.stochD);
            
            const macdThreshold = Math.abs(data.macdLine) * 0.002;
            const stochThreshold = 0.2; // 0.2% of 100 range
            
            if ((macdDiff < macdThreshold) || (stochDiff < stochThreshold)) {
                combinedSignal = 'POTENTIAL';
                reason = 'Indicators approaching crossover';
            }
            
            // Store the signal
            data.lastSignal = {
                symbol: symbol,
                combined: combinedSignal,
                macd: {
                    value: data.macdLine,
                    signal: macdSignal,
                    crossType: macdCrossType
                },
                stoch: {
                    k: data.stochK,
                    d: data.stochD,
                    signal: stochSignal,
                    crossType: stochCrossType
                },
                close: data.candles[data.candles.length - 1].close,
                volume: data.volume,
                reason: reason,
                timestamp: new Date().toISOString()
            };
        }

        // Update the signal display
        function updateSignalDisplay() {
            filterSignals();
        }

        // Filter and display signals based on current filters
        function filterSignals() {
            const signalFilter = document.getElementById('signalFilter').value;
            const searchTerm = document.getElementById('searchSymbol').value.toUpperCase();
            const sortBy = document.getElementById('sortBy').value;
            const resultsLimit = parseInt(document.getElementById('resultsLimit').value) || 50;
            
            // Collect all signals
            let signals = [];
            for (const symbol in symbolData) {
                if (symbolData[symbol].lastSignal) {
                    signals.push(symbolData[symbol].lastSignal);
                }
            }
            
            // Apply filters
            if (signalFilter !== 'all') {
                signals = signals.filter(signal => {
                    if (signalFilter === 'bullish') {
                        return signal.combined.includes('BUY');
                    } else if (signalFilter === 'bearish') {
                        return signal.combined.includes('SELL');
                    } else if (signalFilter === 'potential') {
                        return signal.combined === 'POTENTIAL';
                    }
                    return true;
                });
            }
            
            // Apply search filter
            if (searchTerm) {
                signals = signals.filter(signal => signal.symbol.includes(searchTerm));
            }
            
            // Apply volume filter
            const minVolume = parseFloat(document.getElementById('minVolume').value) || 0;
            if (minVolume > 0) {
                signals = signals.filter(signal => signal.volume >= minVolume);
            }
            
            // Sort signals
            signals.sort((a, b) => {
                if (sortBy === 'symbol') {
                    return a.symbol.localeCompare(b.symbol);
                } else if (sortBy === 'volume') {
                    return b.volume - a.volume;
                } else { // signal-strength
                    // Custom sorting: STRONG BUY > BUY > STRONG SELL > SELL > POTENTIAL > CONFLICT > PARTIAL > NO SIGNAL
                    const strengthOrder = {
                        'STRONG BUY': 0,
                        'BUY': 1,
                        'STRONG SELL': 2,
                        'SELL': 3,
                        'POTENTIAL': 4,
                        'CONFLICT': 5,
                        'PARTIAL': 6,
                        'NO SIGNAL': 7
                    };
                    
                    return strengthOrder[a.combined] - strengthOrder[b.combined];
                }
            });
            
            // Apply results limit
            if (resultsLimit > 0) {
                signals = signals.slice(0, resultsLimit);
            }
            
            // Update counts
            updateSignalCounts(signals);
            
            // Paginate results
            const totalPages = Math.ceil(signals.length / itemsPerPage);
            currentPage = Math.min(currentPage, totalPages || 1);
            
            const startIndex = (currentPage - 1) * itemsPerPage;
            const paginatedSignals = signals.slice(startIndex, startIndex + itemsPerPage);
            
            // Display signals
            displaySignals(paginatedSignals);
            
            // Update pagination controls
            updatePagination(totalPages);
        }

        // Update signal counts in the stats bar
        function updateSignalCounts(signals) {
            const bullish = signals.filter(s => s.combined.includes('BUY')).length;
            const bearish = signals.filter(s => s.combined.includes('SELL')).length;
            const potential = signals.filter(s => s.combined === 'POTENTIAL').length;
            
            document.getElementById('bullishCount').textContent = bullish;
            document.getElementById('bearishCount').textContent = bearish;
            document.getElementById('potentialCount').textContent = potential;
        }

        // Display signals in the grid
        function displaySignals(signals) {
            const grid = document.getElementById('signalGrid');
            grid.innerHTML = '';
            
            if (signals.length === 0) {
                grid.innerHTML = '<div class="no-signals">No signals match your current filters.</div>';
                return;
            }
            
            signals.forEach(signal => {
                const card = document.createElement('div');
                card.className = 'signal-card';
                
                // Add appropriate class based on signal type
                if (signal.combined.includes('BUY')) {
                    card.classList.add('bullish');
                } else if (signal.combined.includes('SELL')) {
                    card.classList.add('bearish');
                } else if (signal.combined === 'POTENTIAL') {
                    card.classList.add('potential');
                }
                
                // Determine badge class
                let badgeClass = '';
                if (signal.combined === 'STRONG BUY') badgeClass = 'strong-buy';
                else if (signal.combined === 'BUY') badgeClass = 'buy';
                else if (signal.combined === 'STRONG SELL') badgeClass = 'strong-sell';
                else if (signal.combined === 'SELL') badgeClass = 'sell';
                else if (signal.combined === 'PARTIAL') badgeClass = 'partial';
                else if (signal.combined === 'CONFLICT') badgeClass = 'conflict';
                
                card.innerHTML = `
                    <div class="card-header">
                        <div class="symbol">${signal.symbol}</div>
                        <div class="signal-badge ${badgeClass}">${signal.combined}</div>
                    </div>
                    <div class="card-details">
                        <div class="detail-item">
                            <span class="detail-label">Close:</span>
                            <span class="detail-value">${signal.close.toFixed(6)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Volume:</span>
                            <span class="detail-value">${signal.volume.toFixed(2)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">MACD:</span>
                            <span class="detail-value">${signal.macd.value.toFixed(6)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">MACD Signal:</span>
                            <span class="detail-value">${signal.macd.signal}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Stoch %K:</span>
                            <span class="detail-value">${signal.stoch.k.toFixed(2)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Stoch %D:</span>
                            <span class="detail-value">${signal.stoch.d.toFixed(2)}</span>
                        </div>
                    </div>
                    <div class="reason">${signal.reason}</div>
                    <div class="timestamp">${new Date(signal.timestamp).toLocaleString()}</div>
                `;
                
                grid.appendChild(card);
            });
        }

        // Update pagination controls
        function updatePagination(totalPages) {
            const pagination = document.getElementById('pagination');
            pagination.innerHTML = '';
            
            if (totalPages <= 1) return;
            
            for (let i = 1; i <= totalPages; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                if (i === currentPage) {
                    button.classList.add('active');
                }
                
                button.addEventListener('click', () => {
                    currentPage = i;
                    filterSignals();
                });
                
                pagination.appendChild(button);
            }
        }

        // Set up auto-refresh
        function setupAutoRefresh() {
            const interval = parseInt(document.getElementById('autoRefresh').value);
            
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
            
            if (interval > 0) {
                refreshInterval = setInterval(() => {
                    lastRefreshTime = new Date();
                    if (isMonitoring) {
                        // In a real implementation, we might refresh historical data here
                        filterSignals();
                    }
                }, interval);
            }
        }

        // Manual refresh
        function manualRefresh() {
            lastRefreshTime = new Date();
            if (isMonitoring) {
                filterSignals();
            }
        }

        // Clear cache
        function clearCache() {
            symbolData = {};
            if (isMonitoring) {
                stopMonitoring();
                isMonitoring = false;
                document.getElementById('startStop').textContent = 'Start Monitoring';
            }
            document.getElementById('signalGrid').innerHTML = '';
            document.getElementById('bullishCount').textContent = '0';
            document.getElementById('bearishCount').textContent = '0';
            document.getElementById('potentialCount').textContent = '0';
        }

        // Run test mode (simplified backtest)
        function runTestMode() {
            alert('Test mode would run a backtest on historical data. In a full implementation, this would download historical candle data and apply the signal logic to it.');
            // This would be a more complex function in a real implementation
        }
    </script>
</body>
</html>